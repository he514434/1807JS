<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		
//		function Fn(n){
//			this.name = n;
//			this.show = function(){
//				console.log(this.name)
//			}
//		}
//		
////		console.dir(Fn)
//		console.log(Fn.prototype)
//		Fn.prototype.init = function(){
//			console.log("哈哈哈哈")
//		}
//		
//		var a = new Fn("aaaa")
////		a.show()
//		a.init()
//		console.log(a)
//		var b = new Fn("bbbb")
////		b.show()
//		b.init()
//		console.log(b)
//		
////		console.log(a == b)
////		console.log(a.show == b.show)		//true
//		console.log(a.init == b.init)		//true
		
//		原型
		
//		var arr = new Array(3,4,5,6,7);
//		var arr2 = new Array(3,4,5,6,7)
////		console.log(arr == arr2)
//		arr.push("last")
//		arr2.push("html")
//		console.log(arr)
//		console.log(arr2)
//		console.log(arr.push == arr2.push)
		
		
		
//		构造函数
		function Fn(n){
			this.name = n;
		}
//		原型
		Fn.prototype.show = function(){
			console.log(this.name)
		}
		var a = new Fn("张三");
		var b = new Fn("张四");
		a.show()
		b.show()
		console.log(a == b)
		console.log(a.show == b.show)
		
//		属性写在构造函数中
//		方法写在函数的原型上
//		不管将来new多少个对象,每个对象虽然不相等,但是每个对象的功能都是一个
//		原型上面的方法中的this,跟构造函数中的this一样,属于预使用,将来都会指向同一个被new出来的同名对象
		
		
	</script>
</html>
